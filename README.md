## Задание
Помните проектную работу?)

https://docs.google.com/document/d/17Ami8tD6VAYlySQm2TbNW_9ft2_jTB049B4vzD1sQ5c/edit?usp=sharing

Вашей задачей в этот раз будет реализация функций распредления драгоценностей эльфам, которые удовлетворяют требованиям, описанным в документе выше, при помощи дерева отрезков.

http://e-maxx.ru/algo/segment_tree


Склонируйте этот репозиторий и реализуйте функции, которые определены в файле `segment-tree.js`. Затем создайте свой собственный репозиторий и залейте код в него.

#### Часть 0. Дерево отрезков

Реализуйте функцию

```js
function segmentTree(array: Array<Any>, fn: function, N: Any): funciton(int, int) -> Any
```

Которая построит дерево отрезков по указанному массиву `array`, которое умеет выполнять ассоциатвную функцию `fn` в кольце с нейтральным элементом `N`.

Аргументы функции:

`array` - массив из любых значений

`fn`- ассоциативная функция, которая умеет каким-то образом комбинировать значения из массива `array`

`N` - нейтральный элемент в кольце, к которому принадлежат элементы `array`

Возвращаемое значение:

функция, с двумя аргументами: левый и правый индексы интересующего диапазона для расчета функции `fn`
`funciton(int, int) -> Any`

Диапазон представляет из себя полуинтервал, где левая граница включена а правая - исключена. В математике это записывается так:
`[from, to)`

Вызов этой функции должен вернуть значение `fn` рассчитанное на указанном интервале.

Подробнее про нейтральный элемент `N`
https://ru.wikipedia.org/wiki/%D0%9D%D0%B5%D0%B9%D1%82%D1%80%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82

Эльфов в высшей степени интересует в качестве `fn` операция суммы. Для неё нейтральный элемент - 0.

Пример:
```js
let array = [1,2,3,4];
function sum(a, b) { return a + b; }
let tree = segmentTree(array, sum, 0);

tree(0, 1); // вернет 1
tree(0, 2); // вернет 3
tree(0, 4); // вернет 10
```

#### Часть 1. Многомерное дерево отрезков

Реализуйте функцию

```js
function recursiveSegmentTree(array: Array<Any>, fn: function, N: Any): funciton(int, int) -> Any
```

Которая принимает в качестве аргументов всё то же самое, что и функция `segmentTree` за одним исключением: массив `array` - многомерный.

Пример для двумерного дерева отрезков: 

```js
    let array = [
      [1, 0, 1, 1],
      [0, 1, 0, 0],
      [0, 0, 0, 1],
      [1, 1, 1, 1]
    ];

    let tree = recursiveSegmentTree(array, sum, 0);

    tree(0, 1)(0, 1) // вернет 1;
    tree(0, 4)(0, 4) // вернет 9
    tree(3, 4)(3, 4) // вернет 1
    tree(2, 3)(2, 3) // вернет 0
```

Пример для трехмерного дерева отрезков

```js
    let array = [
      [[0, 1], [0, 0], [1, 1], [0, 0]],
      [[0, 0], [1, 0], [1, 0], [0, 1]],
      [[0, 0], [1, 0], [0, 1], [1, 0]],
      [[1, 0], [0, 0], [0, 0], [0, 0]],
    ];

    let tree = recursiveSegmentTree(array, sum, 0);

    tree(0, 1)(0, 1)(0, 1) // вернет 0
    tree(2, 3)(0, 4)(0, 2) // вернет 3
    tree(0, 4)(2, 3)(0, 2) // вернет 4
    tree(0, 4)(0, 4)(0, 2) // вернет 10
```

Замечание: с точки зрения JS в данном примере `tree(0, 4)` возвращает снова дерево отрезков, то есть функцию `funciton(int, int) -> Any`
И затем `tree(0, 4)(0, 4)` снова возвращает то же самое.


#### Часть 2. Эльфийское дерево

Реализовать функцию

```js
getElfTree(state: Array<Array<Array<int>>>): Any
```

Которая в качестве аргумета `state` принимает трехмерный массив

`state` - это состояние системы, которое описывает количество драгоценностей полученных каждым эльфом каждую неделю.

```js
state[elf][gem][week]
```

Элемент `state[elf]` массива `state` представляет каждого эльфа. Индекс эльфа `[elf]` соответствует индексу эльфа из массива `allElves`
https://github.com/KypT/segment-tree-assignment/blob/master/tests.js#L1


Элемент `state[elf][gem]` массива `state` представляет драгоценность указанного эльфа `elf`. Индекс драгоценности `[gem]` соответствует индексу драгоценности из массива `allGems`
https://github.com/KypT/segment-tree-assignment/blob/master/tests.js#L2


Элемент `state[elf][gem][week]` массива `state` представляет количесво драгоценностей `[gem]` полученных эльфом `[elf]` в указанную неделю `[week]`

Недели `[week]` считаются от 0 до + бесконечности c момента внедрения системы в страну эльфогномов.

Функция `getElfTree` возвращает любой удовбный для вас тип данных, с которым вам далее будет удобно работать для реализации последующих функций. Однако предполагается (и будет плюсом), если эта функция вернет трехмерное дерево отрезков. Или массив из двумерных деревьев отрезков. Иначе зачем вообще понадобились бы функции `segmentTree` и `recursiveSegmentTree`) Однако последующие задания можно решить и без использования каких-либо деревьев. Например, реализовав эту функцию следующим образом:

```js
function nextState(state, assignment, elves, gems) {
  return state;
}
```

#### Часть 3. Распределяем

Нужно реализовать три функции, каждая из которых занимается распределением драгоценностей эльфам, строго следуя одному из требований в описании проектной работы:

```js
function assignEqually(tree: ElfTree, wishes: Array<Array<float>>, stash: Stash, elves: Array[String], gems: Array<String>, week: int) -> Assignment
```

Данная функция стремится удовлетворить первое требование: все эльфы за всё время должны получить одинаковое количество драгоценностей

Аргументы функции:

`tree: ElfTree` - дерево эльфов, которое было получено в результате вызова функции `getElfTree`

`wishes: Array<Array<float>>` - предпочтения эльфов относительно каждой драгоценности

`wishes[elf][gem]` - это число, которое выражает, насколько эльф `[elf]` любит драгоценность `[gem]`
Каждое значение `wishes[elf][gem]` находится в промежутке `[0, 1]` Сумма всех значений `wishes[elf]` равна `1`

`stash: Stash` - объект с драгоценностями, которые добыли гномы, выглядит следующим образом:

`elves: Array[String]` - массив имен эльфов. Предпочтения эльфа `elves[elf]` представлены массивом `wishes[elf]`

`gems: Array<String>` - массив имен драгоценностей. Предпочтения эльфа `[elf]` к драгоценности `[gem]` `elves[elf][gem]` представлены массивом `wishes[elf][gem]`

`week: int` - порядковый номер недели текущего распределения

Данная функция должна вернуть распределение `Assignment` - объект, который представляет какому эльфу сколько и каких драгоценностей назначено следующего вида:


```js
function assignAtLeastOne(tree: ElfTree, wishes: Array<Array<float>>, stash: Stash, elves: Array[String], gems: Array<String>, week: int) -> Assignment
```

Данная функция стремится удовлетворить второе требование: каждую неделю каждый эльф должен получить хотябы одну драгоценность. Аргументы и возвращаемое значение точно такие же как и у функции `assignEqually`


```js
function assignPreferredGems(tree: ElfTree, wishes: Array<Array<float>>, stash: Stash, elves: Array[String], gems: Array<String>, week: int) -> Assignment
```

Данная функция стремится удовлетворить третье требование: каждому эльфу назначем его любимые драгоценности. Аргументы и возвращаемое значение точно такие же как и у функции `assignEqually`

#### Часть 4. Обновляем состояние системы

Теперь, когда появилась возможность назначать драгоценности эльфам, необходимо производить операцию обновения состояния системы - добавлять в него еще одну неделю согласно назначению.

```js
function nextState(state: Array<Array<Array<int>>>, assignment: Assignment, elves: Array<String>, gems: Array<String>) -> Array<Array<Array<int>>>
```

Аргументы функции: 
`state: Array<Array<Array<int>>>` - текущее состояние системы (см часть 2)
`assignment: Assignment` - назначение драгоценностей эльфам (см часть 3)
`elves: Array<String>` - массив имен эльфов
`gems: Array<String>` - массив имен драгоценностей

Функция возвращает снова состояние системы, в которое добавлена 1 дополнительная неделя согласно указанному распределению.
